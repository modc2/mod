// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";
import "./PaymentTokenWhitelist.sol";
import "./BidSystem.sol";

interface IBlocTimeStaking {
    function fundTreasury(uint256 amount) external;
}

interface IBlocTimeRegistry {
    function getModule(uint256 id) external view returns (
        address owner,
        uint256 pricePerBlock,
        uint256 maxConcurrentUsers,
        uint256 currentUsers,
        bool active,
        string memory ipfsHash
    );
    function isModuleAvailable(uint256 moduleId) external view returns (bool);
    function incrementUsers(uint256 moduleId) external;
    function decrementUsers(uint256 moduleId) external;
}

/**
 * @title BlocTimeMarketplaceMultiToken
 * @dev Enhanced marketplace with multi-token support via whitelist and bid system
 * Allows rentals and listings in any whitelisted ERC20 token with bidding
 */
contract BlocTimeMarketplaceMultiToken is ReentrancyGuard {
    using SafeERC20 for IERC20;

    struct Rental {
        address renter;
        uint256 moduleId;
        uint256 startBlock;
        uint256 paidBlocks;
        address paymentToken;
        bool active;
    }

    struct Listing {
        address seller;
        uint256 rentalId;
        uint256 fromBlock;
        uint256 toBlock;
        uint256 price;
        address paymentToken;
        bool active;
    }

    PaymentTokenWhitelist public whitelist;
    BlocTimeBidSystem public bidSystem;
    IBlocTimeStaking public staking;
    IBlocTimeRegistry public registry;
    IERC20 public nativeToken; // For treasury funding
    uint256 public treasuryFeeBps;
    uint256 public constant MAX_FEE_BPS = 1000;
    
    uint256 public nextRentalId = 1;
    uint256 public nextListingId = 1;

    mapping(uint256 => Rental) public rentals;
    mapping(uint256 => Listing) public listings;
    mapping(address => uint256[]) public userRentals;
    mapping(uint256 => uint256[]) public rentalListings;

    event Rented(uint256 indexed rentalId, uint256 indexed moduleId, address indexed renter, uint256 blocks, uint256 cost, address paymentToken);
    event ListedFractional(uint256 indexed listingId, uint256 indexed rentalId, uint256 fromBlock, uint256 toBlock, uint256 price, address paymentToken);
    event Sold(uint256 indexed listingId, address indexed buyer, uint256 price, address paymentToken);
    event RentalEnded(uint256 indexed rentalId);

    constructor(
        address _whitelist,
        address _nativeToken,
        address _staking,
        address _registry,
        uint256 _feeBps
    ) {
        require(_whitelist != address(0), "Invalid whitelist");
        require(_nativeToken != address(0), "Invalid native token");
        require(_staking != address(0), "Invalid staking");
        require(_registry != address(0), "Invalid registry");
        require(_feeBps <= MAX_FEE_BPS, "Fee too high");
        
        whitelist = PaymentTokenWhitelist(_whitelist);
        nativeToken = IERC20(_nativeToken);
        staking = IBlocTimeStaking(_staking);
        registry = IBlocTimeRegistry(_registry);
        treasuryFeeBps = _feeBps;
        
        // Deploy bid system
        bidSystem = new BlocTimeBidSystem(_whitelist, address(this));
    }

    /**
     * @dev Accept a bid on a rental slot
     */
    function acceptBid(uint256 bidId) external nonReentrant {
        (address bidder, uint256 rentalId, uint256 fromBlock, uint256 toBlock, uint256 bidAmount, address paymentToken, bool active,) = bidSystem.getBid(bidId);
        
        require(active, "Bid not active");
        Rental storage r = rentals[rentalId];
        require(r.renter == msg.sender, "Not slot owner");
        require(r.active, "Rental not active");
        
        // Accept bid in bid system
        bidSystem.acceptBid(bidId, msg.sender);
        
        // Create new rental for bidder
        uint256 newRentalId = nextRentalId++;
        uint256 blockCount = toBlock - fromBlock;
        rentals[newRentalId] = Rental({
            renter: bidder,
            moduleId: r.moduleId,
            startBlock: r.startBlock + fromBlock,
            paidBlocks: blockCount,
            paymentToken: paymentToken,
            active: true
        });
        
        userRentals[bidder].push(newRentalId);
        emit Rented(newRentalId, r.moduleId, bidder, blockCount, bidAmount, paymentToken);
    }

    /**
     * @dev Reject a bid on a rental slot
     */
    function rejectBid(uint256 bidId) external nonReentrant {
        (,uint256 rentalId,,,,, bool active,) = bidSystem.getBid(bidId);
        
        require(active, "Bid not active");
        Rental storage r = rentals[rentalId];
        require(r.renter == msg.sender, "Not slot owner");
        
        bidSystem.rejectBid(bidId, msg.sender);
    }
    function rent(uint256 moduleId, uint256 blocks, address paymentToken) external nonReentrant returns (uint256) {
        require(whitelist.isTokenWhitelisted(paymentToken), "Token not whitelisted");
        require(registry.isModuleAvailable(moduleId), "Module unavailable");
        require(blocks > 0, "Invalid blocks");

        (address owner, uint256 pricePerBlock,,,,) = registry.getModule(moduleId);
        
        uint256 cost = blocks * pricePerBlock;
        uint256 fee = (cost * treasuryFeeBps) / 10000;
        uint256 ownerAmount = cost - fee;

        IERC20(paymentToken).safeTransferFrom(msg.sender, address(this), cost);
        IERC20(paymentToken).safeTransfer(owner, ownerAmount);
        
        // Convert fee to native token if needed, or handle multi-token treasury
        if (fee > 0 && paymentToken == address(nativeToken)) {
            nativeToken.approve(address(staking), fee);
            staking.fundTreasury(fee);
        }

        registry.incrementUsers(moduleId);

        uint256 id = nextRentalId++;
        rentals[id] = Rental({
            renter: msg.sender,
            moduleId: moduleId,
            startBlock: block.number,
            paidBlocks: blocks,
            paymentToken: paymentToken,
            active: true
        });
        
        userRentals[msg.sender].push(id);
        emit Rented(id, moduleId, msg.sender, blocks, cost, paymentToken);
        return id;
    }

    function listFractionalForSale(
        uint256 rentalId,
        uint256 fromBlock,
        uint256 toBlock,
        uint256 price,
        address paymentToken
    ) external returns (uint256) {
        require(whitelist.isTokenWhitelisted(paymentToken), "Token not whitelisted");
        Rental storage r = rentals[rentalId];
        require(r.renter == msg.sender, "Not renter");
        require(r.active, "Rental not active");
        require(fromBlock < toBlock, "Invalid block range");
        require(toBlock <= r.paidBlocks, "Range exceeds paid blocks");
        require(fromBlock >= (block.number - r.startBlock), "Cannot list past blocks");
        require(!hasOverlappingListing(rentalId, fromBlock, toBlock), "Overlapping listing exists");

        uint256 id = nextListingId++;
        listings[id] = Listing({
            seller: msg.sender,
            rentalId: rentalId,
            fromBlock: fromBlock,
            toBlock: toBlock,
            price: price,
            paymentToken: paymentToken,
            active: true
        });
        
        rentalListings[rentalId].push(id);
        emit ListedFractional(id, rentalId, fromBlock, toBlock, price, paymentToken);
        return id;
    }

    function hasOverlappingListing(
        uint256 rentalId,
        uint256 fromBlock,
        uint256 toBlock
    ) public view returns (bool) {
        uint256[] memory listingIds = rentalListings[rentalId];
        
        for (uint256 i = 0; i < listingIds.length; i++) {
            Listing storage l = listings[listingIds[i]];
            if (l.active) {
                if (fromBlock < l.toBlock && l.fromBlock < toBlock) {
                    return true;
                }
            }
        }
        return false;
    }

    function buy(uint256 listingId) external nonReentrant {
        Listing storage l = listings[listingId];
        require(l.active, "Listing not active");
        
        Rental storage r = rentals[l.rentalId];
        require(r.active, "Rental ended");
        require(l.fromBlock >= (block.number - r.startBlock), "Listed period has passed");

        uint256 fee = (l.price * treasuryFeeBps) / 10000;
        uint256 sellerAmount = l.price - fee;

        IERC20(l.paymentToken).safeTransferFrom(msg.sender, address(this), l.price);
        IERC20(l.paymentToken).safeTransfer(l.seller, sellerAmount);

        if (fee > 0 && l.paymentToken == address(nativeToken)) {
            nativeToken.approve(address(staking), fee);
            staking.fundTreasury(fee);
        }

        // Check if subrental is within larger rental space
        uint256 blockCount = l.toBlock - l.fromBlock;
        bool isSubrental = (l.fromBlock > 0 && l.toBlock < r.paidBlocks);
        
        if (isSubrental) {
            // Split into 3 new rental objects
            uint256 blocksPer = blockCount / 3;
            
            for (uint256 i = 0; i < 3; i++) {
                uint256 newRentalId = nextRentalId++;
                uint256 subStartBlock = r.startBlock + l.fromBlock + (i * blocksPer);
                uint256 subBlocks = (i == 2) ? (blockCount - (2 * blocksPer)) : blocksPer;
                
                rentals[newRentalId] = Rental({
                    renter: msg.sender,
                    moduleId: r.moduleId,
                    startBlock: subStartBlock,
                    paidBlocks: subBlocks,
                    paymentToken: l.paymentToken,
                    active: true
                });
                
                userRentals[msg.sender].push(newRentalId);
                emit Rented(newRentalId, r.moduleId, msg.sender, subBlocks, l.price / 3, l.paymentToken);
            }
        } else {
            // Simple transfer - single rental object
            uint256 newRentalId = nextRentalId++;
            rentals[newRentalId] = Rental({
                renter: msg.sender,
                moduleId: r.moduleId,
                startBlock: r.startBlock + l.fromBlock,
                paidBlocks: blockCount,
                paymentToken: l.paymentToken,
                active: true
            });
            
            userRentals[msg.sender].push(newRentalId);
            emit Rented(newRentalId, r.moduleId, msg.sender, blockCount, l.price, l.paymentToken);
        }
        
        l.active = false;

        emit Sold(listingId, msg.sender, l.price, l.paymentToken);
    }

    function cancelListing(uint256 listingId) external {
        Listing storage l = listings[listingId];
        require(l.seller == msg.sender, "Not seller");
        require(l.active, "Listing not active");
        l.active = false;
        
        // Delete storage to save space
        delete listings[listingId];
    }

    function endRental(uint256 rentalId) external {
        Rental storage r = rentals[rentalId];
        require(r.renter == msg.sender, "Not renter");
        require(r.active, "Already ended");
        
        r.active = false;
        registry.decrementUsers(r.moduleId);
        
        uint256[] memory listingIds = rentalListings[rentalId];
        for (uint256 i = 0; i < listingIds.length; i++) {
            if (listings[listingIds[i]].active) {
                listings[listingIds[i]].active = false;
            }
        }
        
        emit RentalEnded(rentalId);
    }

    function getRemainingBlocks(uint256 rentalId) public view returns (uint256) {
        Rental storage r = rentals[rentalId];
        if (!r.active) return 0;
        
        uint256 elapsed = block.number - r.startBlock;
        return r.paidBlocks > elapsed ? r.paidBlocks - elapsed : 0;
    }

    function getRental(uint256 id) external view returns (
        address renter,
        uint256 moduleId,
        uint256 startBlock,
        uint256 paidBlocks,
        address paymentToken,
        bool active
    ) {
        Rental storage r = rentals[id];
        return (r.renter, r.moduleId, r.startBlock, r.paidBlocks, r.paymentToken, r.active);
    }

    function getListing(uint256 id) external view returns (
        address seller,
        uint256 rentalId,
        uint256 fromBlock,
        uint256 toBlock,
        uint256 price,
        address paymentToken,
        bool active
    ) {
        Listing storage l = listings[id];
        return (l.seller, l.rentalId, l.fromBlock, l.toBlock, l.price, l.paymentToken, l.active);
    }

    function getUserRentals(address user) external view returns (uint256[] memory) {
        return userRentals[user];
    }

    function getRentalListings(uint256 rentalId) external view returns (uint256[] memory) {
        return rentalListings[rentalId];
    }
}
